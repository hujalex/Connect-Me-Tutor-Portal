import { getSupabase } from "@/lib/supabase-server/serverClient";
import { Profile } from "@/types";
import {
  createPassword,
  deleteUser,
  sendConfirmationEmail,
} from "./admin.actions";
import { NextResponse } from "next/server";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";

const supabase = createClientComponentClient({
  supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL,
  supabaseKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
});

export const createUser = async (
  email: string,
  password: string
): Promise<string | null> => {
  try {
    // Call signUp to create a new user
    const response = await fetch("/api/admin/create-user", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ email: email, password: password }),
    });

    const data = await response.json();

    if (!response.ok) {
      throw new Error(data.message || `Error: ${response.status}`);
    }

    return data.userId || null;
  } catch (error) {
    console.error("Error creating user:", error);
    return null; // Return null if there was an error
  }
};

export const addTutor = async (
  tutorData: Partial<Profile>
): Promise<Profile> => {
  let userId: string | null = null;
  try {
    if (!tutorData.email) {
      throw new Error("Email is required to create a student profile");
    }

    const lowerCaseEmail = tutorData.email.toLowerCase().trim();

    // Check if a user with this email already exists
    const { data: existingUser, error: userCheckError } = await supabase
      .from("Profiles")
      .select("user_id")
      .eq("email", lowerCaseEmail);

    if (userCheckError && userCheckError.code !== "PGRST116") {
      // PGRST116 means no rows returned, which is what we want
      throw userCheckError;
    }

    if (existingUser && existingUser.length > 0) {
      throw new Error("A user with this email already exists");
    }

    //-----Moved After Duplicate Check to prevent Sending confimration email-----
    const tempPassword = await createPassword();
    userId = await createUser(lowerCaseEmail, tempPassword);

    if (!userId) {
      throw new Error("Failed to create user account");
    }
    // Create the student profile without id and createdAt
    const newTutorProfile = {
      user_id: userId,
      role: "Tutor",
      first_name: tutorData.firstName ? tutorData.firstName.trim() : "",
      last_name: tutorData.lastName ? tutorData.lastName.trim() : "",
      start_date: tutorData.startDate || new Date().toISOString(),
      availability: tutorData.availability || [],
      email: lowerCaseEmail,
      phone_number: tutorData.phoneNumber || "",
      timezone: tutorData.timeZone || "",
      subjects_of_interest: tutorData.subjectsOfInterest || [],
      tutor_ids: [], // Changed from tutorIds to tutor_ids
      status: "Active",
      student_number: null,
    };

    // Add tutor profile to the database
    const { data: profileData, error: profileError } = await supabase
      .from("Profiles") // Ensure 'profiles' is correctly cased
      .insert(newTutorProfile)
      .select("*")
      .single();

    if (profileError) {
      // transaction processing - prevents auth user account with no profile
      await deleteUser(userId);
      throw profileError;
    }

    // Ensure profileData is defined and cast it to the correct type
    if (!profileData) {
      throw new Error("Profile data not returned after insertion");
    }

    await sendConfirmationEmail(profileData.email);
    // Type assertion to ensure profileData is of type Profile
    const createdProfile: Profile = profileData;
    // Return the newly created profile data, including autogenerated fields
    return {
      id: createdProfile.id, // Assuming 'id' is the generated key
      createdAt: createdProfile.createdAt, // Assuming 'created_at' is the generated timestamp
      userId: createdProfile.userId, // Adjust based on your schema
      role: createdProfile.role,
      firstName: createdProfile.firstName,
      lastName: createdProfile.lastName,
      // dateOfBirth: createdProfile.dateOfBirth,
      startDate: createdProfile.startDate,
      availability: createdProfile.availability,
      email: createdProfile.email,
      phoneNumber: createdProfile.phoneNumber,
      parentName: createdProfile.parentName,
      parentPhone: createdProfile.parentPhone,
      parentEmail: createdProfile.parentEmail,
      timeZone: createdProfile.timeZone,
      subjectsOfInterest: createdProfile.subjectsOfInterest,
      tutorIds: createdProfile.tutorIds,
      status: createdProfile.status,
      studentNumber: createdProfile.studentNumber,
      settingsId: createdProfile.settingsId,
    };
  } catch (error) {
    console.error("Error adding tutor:", error);

    if (userId) {
      try {
        await deleteUser(userId);
      } catch (error) {
        console.error("Unable to execute rollback transaction");
      }
    }
    throw error;
  }
};

export const addUser = async (
  userData: Partial<Profile>,
  userRole: "Tutor" | "Student"
): Promise<Profile> => {
  let userId: string | null = null;
  try {
    if (!userData.email) {
      throw new Error("Email is required to create a student profile");
    }

    const lowerCaseEmail = userData.email.toLowerCase().trim();

    // Check if a user with this email already exists
    const { data: existingUser, error: userCheckError } = await supabase
      .from("Profiles")
      .select("user_id")
      .eq("email", lowerCaseEmail);

    if (userCheckError && userCheckError.code !== "PGRST116") {
      // PGRST116 means no rows returned, which is what we want
      throw userCheckError;
    }

    if (existingUser && existingUser.length > 0) {
      throw new Error("A user with this email already exists");
    }

    //-----Moved After Duplicate Check to prevent Sending confimration email-----
    const tempPassword = await createPassword();
    userId = await createUser(lowerCaseEmail, tempPassword);

    if (!userId) {
      throw new Error("Failed to create user account");
    }
    // Create the student profile without id and createdAt
    const newUserProfile = {
      user_id: userId,
      role: userRole,
      first_name: userData.firstName ? userData.firstName.trim() : "",
      last_name: userData.lastName ? userData.lastName.trim() : "",
      age: userData.age || "",
      grade: userData.grade || "",
      gender: userData.gender || "",
      start_date: userData.startDate || new Date().toISOString(),
      availability: userData.availability || [],
      email: lowerCaseEmail,
      parent_name: userData.parentName || "",
      parent_phone: userData.parentPhone || "",
      parent_email: userData.parentEmail || "",

      phone_number: userData.phoneNumber || "",
      timezone: userData.timeZone || "",
      subjects_of_interest: userData.subjectsOfInterest || [],
      tutor_ids: [], // Changed from tutorIds to tutor_ids
      status: "Active",
      student_number: userData.studentNumber || null,
    };

    // Add tutor profile to the database
    const { data: profileData, error: profileError } = await supabase
      .from("Profiles") // Ensure 'profiles' is correctly cased
      .insert(newUserProfile)
      .select("*")
      .single();

    if (profileError) {
      // transaction processing - prevents auth user account with no profile
      await deleteUser(userId);
      throw profileError;
    }

    // Ensure profileData is defined and cast it to the correct type
    if (!profileData) {
      throw new Error("Profile data not returned after insertion");
    }

    await sendConfirmationEmail(profileData.email);
    // Type assertion to ensure profileData is of type Profile
    const createdProfile: Profile = profileData;
    // Return the newly created profile data, including autogenerated fields
    return {
      id: createdProfile.id, // Assuming 'id' is the generated key
      createdAt: createdProfile.createdAt, // Assuming 'created_at' is the generated timestamp
      userId: createdProfile.userId, // Adjust based on your schema
      role: createdProfile.role,
      firstName: createdProfile.firstName,
      lastName: createdProfile.lastName,
      // dateOfBirth: createdProfile.dateOfBirth,
      startDate: createdProfile.startDate,
      availability: createdProfile.availability,
      email: createdProfile.email,
      phoneNumber: createdProfile.phoneNumber,
      parentName: createdProfile.parentName,
      parentPhone: createdProfile.parentPhone,
      parentEmail: createdProfile.parentEmail,
      timeZone: createdProfile.timeZone,
      subjectsOfInterest: createdProfile.subjectsOfInterest,
      tutorIds: createdProfile.tutorIds,
      status: createdProfile.status,
      studentNumber: createdProfile.studentNumber,
      settingsId: createdProfile.settingsId,
    };
  } catch (error) {
    console.error("Error adding tutor:", error);

    if (userId) {
      try {
        await deleteUser(userId);
      } catch (error) {
        console.error("Unable to execute rollback transaction");
      }
    }
    throw error;
  }
};
